# -*- coding: utf-8 -*-
"""
Created on Fri Jul 17 10:45:28 2020

@author: Gustavo Caldas
"""
###Ferramentas de Otimizacao Usando Algoritmos Genéticos
###Exemplo Inicial - Aula 4 
import random 
import numpy 
from deap import algorithms 
from deap import base
from deap import creator 
from deap import tools

## Preparação para otimização
# 1.Funcao Objetivo
# 2. Variaveis de Decisao
# 3. Operadores

#     1. Creation of fitness function - Função Objetivo
#     1.1 function declaration
def objective_function(individual): #individual is a list, it could be an array
    return (-individual[0]**2 + 2*individual[0] + 8), #tupla 
                                                      #individual has length 1 



creator.create("FitnessMax", base.Fitness, weights=(1.0,))   #tupla again with comma
#  Some comments:
# função objetivo: nome, tipo(f.o.), peso de cada objetivo (no caso só um objetivo); peso positivo = maximização
# base.Fitness is a pre-defined class. Fitnessmax will extend the class - inherit
# instation = making attributes

 
                                                    
#       1.2 Creating the individual class
# Instantiate fitness=creator.Max, previously created. 
# Each instance of this Individual class will have an attribute called fitness, of
# the FitnessMax class we previously created. 
creator.create("Individual", list,  fitness=creator.FitnessMax)   # Individual - list type



#       1.3 Using the toolbox class
# The second mechanism offered by the DEAP framework is the base.Toolbox class. 
# The Toolbox is used as a container for functions (or operators), and enables us
# to create new operators by aliasing and customizing existing functions.
toolbox = base.Toolbox()




# Gerador de atributos inteiros: nome, tipo das variáveis, intervalo (limites inferior e superior)
toolbox.register("attr_int", random.uniform, -10, 10)

# Inicializador de indivíduo e população
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_int, 1)   # 1: número de variáveis de decisão
toolbox.register("population", tools.initRepeat, list, toolbox.individual)                  # lista de indivíduos

# Incializador de operadores. First argument as alias to existing function
toolbox.register("evaluate", objective_function) # função objetivo
toolbox.register("mate", tools.cxSimulatedBinaryBounded) #offspring from crossover                  
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.05)  #parametrs of probability mutation
toolbox.register("select", tools.selRoulette) #select

pop = toolbox.population(n=50)                            # inicialização da pop
hof = tools.HallOfFame(1)                                 # melhor indivíduo
stats = tools.Statistics(lambda ind: ind.fitness.values)  # estatísticas
stats.register("avg", numpy.mean)
stats.register("std", numpy.std)
stats.register("min", numpy.min)
stats.register("max", numpy.max)

"""## Otimização"""

pop, log = algorithms.eaSimple(pop, toolbox, cxpb=0, mutpb=0.1, ngen=20, stats=stats, halloffame=hof, verbose=True)

"""## Resultados"""

# 5 melhores soluções da última geração
import pandas as pd
pd.DataFrame(pop).head(5)

# Melhor solução
print("Melhor Indivíduo:")
print(hof)

# Melhor resultado da função objetivo
print("Melhor Resultado da Função Objetivo:")
objective_function(hof[0])

# Vamos dar uma olhada na função
import matplotlib.pyplot as plt
x = numpy.linspace(-10,10,100) # 100 pontos entre -10 e 10
y=numpy.empty(len(x))
for i in range(len(x)):
  y[i] = objective_function([x[i]])[0]
plt.plot(x,y); # Variável de Decisão vs. Função Objetivo
plt.scatter(hof,objective_function(hof[0]), c='red');
plt.xlabel('Variável de Decisão');
plt.ylabel('Função Objetivo');
